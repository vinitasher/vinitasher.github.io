<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Baby Shower — Plan</title>
  <style>
    :root{font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;line-height:1.6;color:#222}
    body{max-width:900px;margin:32px auto;padding:0 20px}
    pre,code{background:#f6f8fa;padding:.2em .4em;border-radius:4px}
    h1,h2,h3{color:#1a3a5a}
    .meta{color:#556;margin-bottom:1rem}
    a.edit{font-size:0.9rem;margin-left:8px}
  </style>
</head>
<body>
  <main id="content">Loading plan…</main>
  <p class="meta">This page renders <a href="README.html">README</a> in this folder. <a class="edit" href="https://github.com/vinitasher/vinitasher.github.io/blob/master/baby-shower/README.md" target="_blank" rel="noopener">Edit on GitHub</a></p>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
  <script>
    async function renderReadme(){
      try{
        const res = await fetch('README.md');
        if(!res.ok) throw new Error('README.md not found');
        const md = await res.text();
        // Use marked to convert markdown -> HTML, then sanitize with DOMPurify
        const html = marked.parse(md);
        const sanitized = DOMPurify.sanitize(html);
        const container = document.getElementById('content');
        container.innerHTML = sanitized;

        // Make checklist checkboxes interactive and persist their state per page
        try{
          const prefix = location.pathname + '::README.md';
          const checkboxes = Array.from(container.querySelectorAll('input[type="checkbox"]'));
          checkboxes.forEach((cb, i) => {
            // some renderers mark task inputs as disabled; enable them
            cb.removeAttribute('disabled');
            // derive a stable key per page + index
            const key = prefix + '::cb::' + i;
            const saved = localStorage.getItem(key);
            if(saved !== null) cb.checked = saved === '1';
            cb.addEventListener('change', () => {
              localStorage.setItem(key, cb.checked ? '1' : '0');
            });
          });

          // Add a small control to clear saved checklist state for this page
          let controls = document.getElementById('md-controls');
          if(!controls){
            controls = document.createElement('div');
            controls.id = 'md-controls';
            controls.style.marginTop = '12px';
            document.body.insertBefore(controls, document.body.firstChild);
          }
          // avoid adding multiple buttons
          if(!document.getElementById('clear-checks')){
            const btn = document.createElement('button');
            btn.id = 'clear-checks';
            btn.textContent = 'Clear checklist state';
            btn.style.margin = '6px';
            btn.addEventListener('click', () => {
              const keys = Object.keys(localStorage).filter(k => k.startsWith(prefix + '::cb::'));
              keys.forEach(k => localStorage.removeItem(k));
              checkboxes.forEach(cb => cb.checked = false);
            });
            controls.appendChild(btn);
          }
        }catch(e){
          // non-fatal; continue
          console.warn('checkbox persistence failed', e);
        }
      }catch(e){
        document.getElementById('content').textContent = e.message;
      }
    }
    renderReadme();
  </script>
</body>
</html>
